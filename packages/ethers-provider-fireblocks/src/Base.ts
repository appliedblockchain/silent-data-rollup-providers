import {
  DEBUG_NAMESPACE,
  delegateEIP712Types,
  DelegateSignerMessage,
  eip712Domain,
  getAuthEIP712Types,
  SignatureType,
  SilentDataRollupBase,
} from '@appliedblockchain/silentdatarollup-core'
import debug from 'debug'
import { hashMessage, JsonRpcPayload, Signer } from 'ethers'
import {
  PeerType,
  TransactionArguments,
  TransactionOperation,
} from 'fireblocks-sdk'
import { EIP712Domain } from './constants'

const log = debug(DEBUG_NAMESPACE)

export class SilentDataRollupFireblocksBase extends SilentDataRollupBase {
  public async createPersonalSignature(
    provider: any,
    content: any,
    operation: TransactionOperation,
    type?: SignatureType,
  ): Promise<string> {
    log('Signing message. Operation:', {
      operation,
      type,
      content,
    })
    const vaultAccountId = provider.ethereum.vaultAccountIds[0]?.toString()
    log('Using vault account ID:', vaultAccountId)
    const transactionArguments: TransactionArguments = {
      operation,
      assetId: provider.ethereum.assetId,
      source: {
        type: PeerType.VAULT_ACCOUNT,
        id: vaultAccountId,
      },
      extraParameters: {
        rawMessageData: {
          messages: [
            { content, ...(type === SignatureType.EIP712 ? { type } : {}) },
          ],
        },
      },
    }

    log('Creating transaction', JSON.stringify(transactionArguments, null, 2))
    const txInfo =
      await provider.ethereum.createTransaction(transactionArguments)
    log('Transaction created. TxInfo:', txInfo)
    const sig = txInfo!.signedMessages![0].signature
    const v = 27 + sig.v!
    const signature = '0x' + sig.r + sig.s + v.toString(16)
    log('Signature generated:', signature)
    return signature
  }

  public async signDelegateHeader(
    provider: any,
    message: string,
    isSWC?: boolean,
  ): Promise<string> {
    void isSWC
    log('Signing raw delegate header. Message:', message)
    const hashedMessage = hashMessage(message).slice(2)
    return this.createPersonalSignature(
      provider,
      hashedMessage,
      TransactionOperation.RAW,
      SignatureType.Raw,
    )
  }

  public async signTypedDelegateHeader(
    provider: any,
    chainId: string,
    message: DelegateSignerMessage,
    isSWC?: boolean,
  ) {
    void isSWC
    log('Signing typed delegate header. Message:', message)

    const content = {
      types: {
        EIP712Domain,
        ...delegateEIP712Types,
      },
      primaryType: 'Ticket',
      domain: { ...eip712Domain, chainId },
      message: message,
    }

    log('EIP712 content created:', content)
    return this.createPersonalSignature(
      provider,
      content,
      TransactionOperation.TYPED_MESSAGE,
      SignatureType.EIP712,
    )
  }

  public async signAuthHeader(
    provider: any,
    payload: JsonRpcPayload | JsonRpcPayload[],
    timestamp: string,
    chainId: string,
    isSWC?: boolean,
  ): Promise<string> {
    void isSWC
    log('Preparing raw message for signing')
    const message = this.prepareMessage(chainId, payload, timestamp)
    log('Raw message:', message)
    let signature: string
    if (this.config.delegate) {
      const delegateSigner = await this.getDelegateSigner(this)
      signature = await this.signMessage(delegateSigner, message)
      log('Raw signature generated by delegate signer:', signature)
    } else {
      log('Message to be hashed:', JSON.stringify(message))
      const hashedMessage = hashMessage(message).slice(2)
      log('Hashed message:', hashedMessage)

      signature = await this.createPersonalSignature(
        provider,
        hashedMessage,
        TransactionOperation.RAW,
      )
    }

    log('Raw signature generated:', signature)
    return signature
  }

  public async signTypedAuthHeader(
    provider: any,
    payload: JsonRpcPayload | JsonRpcPayload[],
    timestamp: string,
    chainId: string,
    isSWC?: boolean,
  ): Promise<string> {
    void isSWC
    const types = getAuthEIP712Types(payload)
    const message = this.prepareTypedData(payload, timestamp)
    const content = {
      types: {
        EIP712Domain,
        ...types,
      },
      primaryType: 'Call',
      domain: { ...eip712Domain, chainId },
      message: message,
    }

    log('EIP712 content created:', content)
    let signature: string
    if (this.config.delegate) {
      const delegateSigner = await this.getDelegateSigner(this)
      const domain = { ...eip712Domain, chainId: chainId.toString() }
      signature = await (delegateSigner as Signer).signTypedData(
        domain,
        types,
        message,
      )
    } else {
      signature = await this.createPersonalSignature(
        provider,
        content,
        TransactionOperation.TYPED_MESSAGE,
        SignatureType.EIP712,
      )
    }

    log('Typed signature generated:', signature)
    return signature
  }
}
